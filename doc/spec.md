# Sp√©cification - Simulateur kubectl avec xterm.js

## üéØ Vue d'ensemble

Application web interactive permettant de s'entra√Æner aux commandes `kubectl` via un terminal simul√©, avec un cluster Kubernetes virtuel stateful.

---

## üìã Objectifs principaux

### Phase 1 : MVP (Minimum Viable Product)
- Terminal xterm.js centr√© et styl√©
- Interpr√©teur de commandes kubectl basique (`get`, `describe`, `delete`, `create`, `apply`)
- Cluster virtuel stateful en m√©moire (namespaces, pods, deployments, services)
- Persistance locale (localStorage/IndexedDB)
- Support des ressources de base : Pods, Deployments, Services, Namespaces

### Phase 2 : √âvolution (Future)
- Simulation de contr√¥leurs Kubernetes (reconciliation loops)
- G√©n√©ration dynamique de ressources
- Simulation de pannes et red√©marrages
- M√©triques et logs simul√©s
- Scenarios d'entra√Ænement guid√©s

### Phase 3 : Learning Platform (Long-term)
- **Challenges System** : Scenarios avec seed clusters pr√©-configur√©s
- **Lessons UI** : Interface p√©dagogique avec texte, explications, progression
- **Visual Cluster** : Repr√©sentation graphique de l'√©tat du cluster

---

## üèóÔ∏è Architecture technique

### Stack technologique
- **Frontend** : HTML5, TypeScript, CSS (BEM)
- **Terminal** : xterm.js
- **Build** : Vite [[memory:7046759]]
- **UI Framework** : daisyUI [[memory:6873963]]
- **Tests** : Vitest
- **Persistance** : localStorage (Phase 1), IndexedDB (Phase 2+)

### Principes architecturaux [[memory:6873972]]
- **KISS** : Keep It Simple, Stupid
- **DRY** : Don't Repeat Yourself
- **Functional Programming** : √âviter les classes, pr√©f√©rer les fonctions pures et les closures
- **Clean Architecture** : S√©paration des responsabilit√©s
- **D√©couplage** : Modules ind√©pendants et testables
- **Indentation max** : 3 niveaux [[memory:7046752]]
- **Pas de switch statements** [[memory:7046752]]

### Structure des modules

```
src/
‚îú‚îÄ‚îÄ kubectl/                       # Feature: kubectl simulation
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser.ts              # Parse les commandes kubectl (fonction pure)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor.ts            # Ex√©cute les commandes (factory function)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/              # Handlers par commande (fonctions pures)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ get.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ describe.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ delete.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ create.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ apply.ts
‚îÇ   ‚îî‚îÄ‚îÄ formatters/
‚îÇ       ‚îî‚îÄ‚îÄ table-formatter.ts     # Format output en tables (fonction pure)
‚îú‚îÄ‚îÄ cluster/                       # Feature: cluster K8s
‚îÇ   ‚îú‚îÄ‚îÄ ClusterState.ts            # √âtat du cluster (factory function)
‚îÇ   ‚îú‚îÄ‚îÄ models/                    # Mod√®les de ressources K8s
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Pod.ts                 # Factory functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deployment.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Namespace.ts
‚îÇ   ‚îú‚îÄ‚îÄ seedCluster.ts             # Donn√©es initiales (fonction pure)
‚îÇ   ‚îî‚îÄ‚îÄ storage/
‚îÇ       ‚îî‚îÄ‚îÄ adapter.ts             # Abstraction persistance (factory function)
‚îú‚îÄ‚îÄ filesystem/                    # Feature: Virtual file system (Phase 1)
‚îÇ   ‚îú‚îÄ‚îÄ FileSystem.ts              # √âtat du filesystem (factory function)
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ File.ts                # Factory pour fichiers (YAML manifests)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Directory.ts           # Factory pour dossiers
‚îÇ   ‚îî‚îÄ‚îÄ seedFileSystem.ts          # Filesystem initial (root + exemples)
‚îú‚îÄ‚îÄ shell/                         # Feature: Shell commands (Phase 1)
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser.ts              # Parse commandes shell (cd, ls, mkdir, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor.ts            # Ex√©cute commandes shell
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/              # Handlers par commande (fonctions pures)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cd.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ls.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ pwd.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ mkdir.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ touch.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cat.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ rm.ts
‚îÇ   ‚îî‚îÄ‚îÄ formatters/
‚îÇ       ‚îî‚îÄ‚îÄ ls-formatter.ts        # Format output de ls
‚îú‚îÄ‚îÄ editor/                        # Feature: Terminal-based YAML editor (Phase 2)
‚îÇ   ‚îî‚îÄ‚îÄ TerminalEditor.ts          # √âditeur dans xterm (nano-like)
‚îú‚îÄ‚îÄ terminal/
‚îÇ   ‚îî‚îÄ‚îÄ TerminalManager.ts         # Gestion xterm.js (factory function)
‚îú‚îÄ‚îÄ learning/                      # Feature: Learning platform (Phase 3)
‚îÇ   ‚îú‚îÄ‚îÄ challenges/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Challenge.ts           # Types et factory pour challenges
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scenarios/             # Seed clusters pr√©-configur√©s par sc√©nario
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debugCrashingPod.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scalingDeployment.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ networkingIssue.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.ts           # Validation des solutions (fonctions pures)
‚îÇ   ‚îú‚îÄ‚îÄ lessons/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Lesson.ts              # Types et factory pour lessons
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content/               # Contenu des le√ßons (markdown ou JSON)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ intro-pods.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deployments.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LessonUI.ts            # Composant UI pour afficher le√ßons
‚îÇ   ‚îî‚îÄ‚îÄ visualizer/                # Visualisation du cluster (Phase 3)
‚îÇ       ‚îú‚îÄ‚îÄ ClusterVisualizer.ts   # Factory pour le visualizer
‚îÇ       ‚îî‚îÄ‚îÄ renderers/             # Renderers pour diff√©rentes vues
‚îÇ           ‚îú‚îÄ‚îÄ graph.ts           # Vue graphe (nodes/pods)
‚îÇ           ‚îî‚îÄ‚îÄ tree.ts            # Vue arbre (namespace > deployment > pods)
‚îî‚îÄ‚îÄ main.ts                        # Point d'entr√©e
```

---

## üíæ Mod√®le de donn√©es

### √âtat du cluster (ClusterState)

```typescript
interface ClusterState {
  namespaces: Namespace[]
  pods: Pod[]
  deployments: Deployment[]
  services: Service[]
  replicaSets?: ReplicaSet[]  // Phase 2
  events?: Event[]            // Phase 2
}
```

### √âtat du filesystem (FileSystem)

```typescript
interface FileSystemState {
  currentPath: string         // Chemin courant (e.g., "/manifests/dev")
  tree: DirectoryNode         // Arbre du filesystem (racine)
}

interface DirectoryNode {
  type: "directory"
  name: string
  path: string                // Chemin absolu
  children: Map<string, FileSystemNode>
}

interface FileNode {
  type: "file"
  name: string
  path: string                // Chemin absolu
  content: string             // Contenu du fichier (YAML)
  createdAt: string
  modifiedAt: string
}

type FileSystemNode = DirectoryNode | FileNode

// Factory functions (functional programming)
const createDirectory = (name: string, path: string): DirectoryNode => ({
  type: "directory",
  name,
  path,
  children: new Map()
})

const createFile = (name: string, path: string, content = ""): FileNode => ({
  type: "file",
  name,
  path,
  content,
  createdAt: new Date().toISOString(),
  modifiedAt: new Date().toISOString()
})
```

### Contraintes du filesystem

- **Profondeur maximale** : 3 niveaux (racine + 3)
  - Exemple valide : `/manifests/dev/pods/nginx.yaml` (profondeur 3)
  - Exemple invalide : `/a/b/c/d/file.yaml` (profondeur 4)
- **Noms de fichiers** : alphanum√©rique + `-_./`
- **Extensions** : `.yaml`, `.yml` support√©es
- **Caract√®res interdits** : `*`, `?`, `<`, `>`, `|`, espaces
- **Chemins** : Format Unix (`/path/to/file`)
- **Racine** : Toujours `/` (home directory virtuel)

### Exemple de ressource Pod

```typescript
interface Pod {
  apiVersion: "v1"
  kind: "Pod"
  metadata: {
    name: string
    namespace: string
    labels?: Record<string, string>
    creationTimestamp: string
  }
  spec: {
    containers: Container[]
  }
  status: {
    phase: "Pending" | "Running" | "Succeeded" | "Failed" | "Unknown"
    restartCount: number
    containerStatuses?: ContainerStatus[]
  }
}

// Factory function (functional programming)
const createPod = (name: string, namespace: string, containers: Container[]): Pod => ({
  apiVersion: "v1",
  kind: "Pod",
  metadata: {
    name,
    namespace,
    creationTimestamp: new Date().toISOString()
  },
  spec: { containers },
  status: {
    phase: "Pending",
    restartCount: 0
  }
})
```

---

## üéÆ Fonctionnalit√©s d√©taill√©es

### Commandes kubectl support√©es (Phase 1)

| Commande | Description | Priorit√© |
|----------|-------------|----------|
| `kubectl get pods` | Liste les pods | ‚≠ê‚≠ê‚≠ê |
| `kubectl get pods -n <namespace>` | Liste pods par namespace | ‚≠ê‚≠ê‚≠ê |
| `kubectl get deployments` | Liste les deployments | ‚≠ê‚≠ê‚≠ê |
| `kubectl get services` | Liste les services | ‚≠ê‚≠ê‚≠ê |
| `kubectl describe pod <name>` | D√©tails d'un pod | ‚≠ê‚≠ê |
| `kubectl delete pod <name>` | Supprime un pod | ‚≠ê‚≠ê‚≠ê |
| `kubectl create -f <yaml>` | Cr√©e une ressource | ‚≠ê‚≠ê |
| `kubectl apply -f <yaml>` | Applique une ressource | ‚≠ê‚≠ê |
| `kubectl get all` | Liste toutes les ressources | ‚≠ê |
| `kubectl get namespaces` | Liste les namespaces | ‚≠ê‚≠ê |
| `kubectl edit pod <name>` | √âdite un pod (ouvre √©diteur) | ‚≠ê‚≠ê (Phase 2) |

### Commandes shell support√©es (Phase 1)

| Commande | Description | Priorit√© |
|----------|-------------|----------|
| `pwd` | Affiche le r√©pertoire courant | ‚≠ê‚≠ê‚≠ê |
| `ls` | Liste fichiers/dossiers | ‚≠ê‚≠ê‚≠ê |
| `ls -l` | Liste d√©taill√©e | ‚≠ê‚≠ê |
| `cd <path>` | Change de r√©pertoire | ‚≠ê‚≠ê‚≠ê |
| `cd ..` | Remonte d'un niveau | ‚≠ê‚≠ê‚≠ê |
| `cd /` | Retourne √† la racine | ‚≠ê‚≠ê‚≠ê |
| `mkdir <name>` | Cr√©e un dossier | ‚≠ê‚≠ê‚≠ê |
| `mkdir -p <path>` | Cr√©e dossiers r√©cursifs (max 3 niveaux) | ‚≠ê‚≠ê |
| `touch <file>` | Cr√©e un fichier vide | ‚≠ê‚≠ê‚≠ê |
| `cat <file>` | Affiche contenu d'un fichier | ‚≠ê‚≠ê‚≠ê |
| `rm <file>` | Supprime un fichier | ‚≠ê‚≠ê |
| `rm -r <dir>` | Supprime un dossier | ‚≠ê‚≠ê |
| `clear` | Efface le terminal | ‚≠ê‚≠ê‚≠ê |
| `help` | Affiche l'aide | ‚≠ê‚≠ê‚≠ê |

### Int√©gration kubectl + filesystem

Les commandes kubectl peuvent r√©f√©rencer des fichiers du filesystem virtuel :

```bash
# Cr√©er un manifest
touch pod.yaml
# Ouvrir l'√©diteur pour √©diter le fichier
kubectl apply -f pod.yaml

# Organisation en dossiers
mkdir -p manifests/dev
cd manifests/dev
touch nginx-pod.yaml
kubectl apply -f nginx-pod.yaml

# R√©f√©rence avec chemins
kubectl apply -f /manifests/dev/nginx-pod.yaml
kubectl apply -f ../prod/redis-pod.yaml
```

### Donn√©es initiales (Seed Cluster)

Cluster pr√©-peupl√© avec :
- Namespaces : `default`, `kube-system`
- Quelques pods exemple (nginx, redis, etc.)
- 1-2 deployments
- 1-2 services

### Donn√©es initiales (Seed FileSystem)

Filesystem pr√©-peupl√© avec structure exemple :

```
/ (racine)
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ pod-example.yaml        # Exemple de Pod simple
‚îÇ   ‚îú‚îÄ‚îÄ deployment-example.yaml # Exemple de Deployment
‚îÇ   ‚îî‚îÄ‚îÄ service-example.yaml    # Exemple de Service
‚îî‚îÄ‚îÄ manifests/
    ‚îî‚îÄ‚îÄ (vide - dossier pour l'utilisateur)
```

**Contenu de `/examples/pod-example.yaml`** :
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
```

L'utilisateur peut :
- Explorer `/examples/` pour apprendre la syntaxe
- Utiliser `cat examples/pod-example.yaml` pour voir le contenu
- Cr√©er ses propres manifests dans `/manifests/`
- Organiser ses fichiers (max 3 niveaux de profondeur)

---

## üé® Interface utilisateur

### Layout Phase 1 (MVP)
- Terminal centr√© horizontalement et verticalement
- Largeur responsive (max-width pour lisibilit√©)
- Theme daisyUI dark [[memory:7046767]]
- Tailwind CSS utility classes (pas de BEM)

### Prompt Terminal Dynamique

Le prompt du terminal s'adapte selon le contexte :

```bash
# √Ä la racine
kubectl> ls

# Dans un dossier
~/manifests> pwd
/manifests

# Dans un sous-dossier (affiche chemin relatif)
~/manifests/dev> ls
```

**Format du prompt** :
- Racine `/` ‚Üí `kubectl> `
- Autres dossiers ‚Üí `~{chemin}> ` (ex: `~/manifests/dev> `)
- Couleur : vert (success) pour coh√©rence avec terminaux Unix
- Apr√®s erreur : reste vert (pas de changement de couleur)

**Impl√©mentation** :
```typescript
const getPrompt = (currentPath: string): string => {
  if (currentPath === '/') return 'kubectl> '
  return `~${currentPath}> `
}
```

### Layout Phase 3 (Learning Platform)
- **Layout hybride** : Terminal + Panneau lat√©ral p√©dagogique
  - Terminal principal (70% largeur)
  - Panneau lat√©ral droit (30% largeur) : Lessons, hints, objectives
- **Modes d'affichage** :
  - Mode "Terminal only" : plein √©cran (MVP actuel)
  - Mode "Learning" : split view avec lessons
  - Mode "Visual" : split view avec visualisation cluster
  - Mode "Challenge" : terminal + objectifs + validation
- **Components UI (daisyUI)** :
  - Cards pour les lessons
  - Accord√©ons pour les sections
  - Progress bars pour la progression
  - Badges pour les achievements
  - Buttons pour la navigation (Next, Previous, Try Again)

### Exemple d'impl√©mentation fonctionnelle

```typescript
// Terminal: Factory function avec closures
export const createTerminalManager = (container: HTMLElement) => {
  const terminal = new Terminal({ /* config */ })
  let currentLine = ''
  let commandCallback: ((cmd: string) => void) | undefined
  
  const handleInput = (data: string) => {
    // Logic...
  }
  
  terminal.open(container)
  terminal.onData(handleInput)
  
  return {
    write: (text: string) => terminal.write(text),
    onCommand: (cb) => { commandCallback = cb },
    showPrompt: () => terminal.write('kubectl> '),
    focus: () => terminal.focus()
  }
}
```

```typescript
// Command Dispatcher: Route vers kubectl ou shell commands
export const createCommandDispatcher = (
  clusterState: ClusterState,
  fileSystem: FileSystem,
  terminal: TerminalManager
) => {
  const kubectlExecutor = createKubectlExecutor(clusterState, fileSystem)
  const shellExecutor = createShellExecutor(fileSystem)
  
  const dispatch = (input: string): string => {
    const trimmed = input.trim()
    
    if (trimmed.startsWith('kubectl ')) {
      return kubectlExecutor.execute(trimmed)
    }
    
    // Shell commands (cd, ls, pwd, mkdir, touch, cat, rm, clear, help)
    return shellExecutor.execute(trimmed)
  }
  
  return { dispatch }
}
```

```typescript
// FileSystem: Factory function avec closures + pure functions
// Pure functions pour les op√©rations
const resolvePath = (currentPath: string, targetPath: string): string => {
  // R√©sout chemin relatif/absolu
  if (targetPath.startsWith('/')) return targetPath
  // ... logic
}

const getDepth = (path: string): number => {
  return path.split('/').filter(p => p.length > 0).length
}

const findNode = (tree: DirectoryNode, path: string): FileSystemNode | undefined => {
  // Traverse l'arbre pour trouver le n≈ìud (fonction pure)
}

// Facade avec closures
export const createFileSystem = (initialState?: FileSystemState) => {
  let state: FileSystemState = initialState || {
    currentPath: '/',
    tree: createDirectory('root', '/')
  }

  return {
    getCurrentPath: () => state.currentPath,
    
    changeDirectory: (path: string) => {
      const absolutePath = resolvePath(state.currentPath, path)
      const node = findNode(state.tree, absolutePath)
      
      if (!node || node.type !== 'directory') {
        return { type: 'error', message: 'Directory not found' }
      }
      
      state = { ...state, currentPath: absolutePath }
      return { type: 'success', data: absolutePath }
    },
    
    listDirectory: (path?: string) => {
      const targetPath = path ? resolvePath(state.currentPath, path) : state.currentPath
      const node = findNode(state.tree, targetPath)
      
      if (!node || node.type !== 'directory') {
        return { type: 'error', message: 'Not a directory' }
      }
      
      return { type: 'success', data: Array.from(node.children.values()) }
    },
    
    createDirectory: (name: string) => {
      const newPath = `${state.currentPath}/${name}`.replace('//', '/')
      
      if (getDepth(newPath) > 3) {
        return { type: 'error', message: 'Max depth of 3 exceeded' }
      }
      
      // ... mutation de state.tree (immutable update)
      return { type: 'success', data: newPath }
    },
    
    createFile: (name: string, content = '') => {
      const newPath = `${state.currentPath}/${name}`.replace('//', '/')
      // ... cr√©er fichier
    },
    
    readFile: (path: string) => {
      const absolutePath = resolvePath(state.currentPath, path)
      const node = findNode(state.tree, absolutePath)
      
      if (!node || node.type !== 'file') {
        return { type: 'error', message: 'File not found' }
      }
      
      return { type: 'success', data: node.content }
    },
    
    writeFile: (path: string, content: string) => {
      // Update file content (immutable)
    },
    
    toJSON: () => state,
    loadState: (newState: FileSystemState) => { state = newState }
  }
}
```

---

## ‚úÖ Tests (TDD)

### Framework de tests
- **Vitest** : Int√©gration native avec Vite, TypeScript support
- **jsdom** : Pour tester les interactions DOM (terminal)

### Couverture souhait√©e
- **Parseur de commandes** : 100%
- **Gestionnaire de ressources** : 100%
- **Handlers de commandes** : 80%+
- **Formatage output** : 80%+

### Types de tests
- Tests unitaires pour chaque module (fonctions pures = faciles √† tester)
- Tests d'int√©gration pour les flux complets
- Tests de snapshot pour l'output format√© (?)

### Exemple de test fonctionnel

```typescript
// Fonction pure = test simple
describe('parseCommand', () => {
  it('should parse get pods command', () => {
    const result = parseCommand('kubectl get pods')
    expect(result).toEqual({
      action: 'get',
      resource: 'pods',
      name: undefined,
      flags: {}
    })
  })
})

// Factory function = test avec setup
describe('createTerminalManager', () => {
  it('should handle commands', () => {
    const container = document.createElement('div')
    const terminal = createTerminalManager(container)
    const callback = vi.fn()
    
    terminal.onCommand(callback)
    terminal.simulateInput('test\r')
    
    expect(callback).toHaveBeenCalledWith('test')
  })
})
```

---

## ‚úÖ D√©cisions techniques

### Phase 1 (MVP)
- **Framework de tests** : ‚úÖ Vitest
- **Persistance** : ‚úÖ localStorage (IndexedDB en Phase 2 si besoin)
- **Parser YAML/JSON** : ‚úÖ js-yaml pour kubectl apply/create (Phase 1)
- **TypeScript** : ‚úÖ Strict mode activ√©
- **Messages d'erreur** : ‚úÖ Simplifi√©s mais architecture flexible
- **Terminal** : ‚úÖ Saisie basique uniquement
- **Interface** : ‚úÖ Terminal uniquement (pas de sidebar)
- **Th√®me** : ‚úÖ Dark theme (daisyUI + xterm)
- **Commandes kubectl** : ‚úÖ get, describe, delete, apply, create
- **Commandes shell** : ‚úÖ cd, ls, pwd, mkdir, touch, cat, rm, clear, help
- **Virtual FileSystem** : ‚úÖ Max 3 niveaux de profondeur
- **√âditeur YAML** : ‚ùå Phase 2 (terminal-based editor dans xterm)

### Phase 2 (Enhanced Features)
- **√âditeur YAML** : Terminal-based editor (nano-like) dans xterm
  - Navigation avec fl√®ches
  - √âdition de fichiers YAML
  - Ctrl+S pour sauvegarder, Ctrl+Q pour quitter
  - Int√©gration avec kubectl edit
  - Pas de d√©pendances externes (uniquement xterm)
- Historique commandes (‚Üë‚Üì), autocompl√©tion (Tab)
- IndexedDB si localStorage insuffisant
- Messages d'erreur type kubectl r√©el
- Syntax highlighting ANSI dans l'√©diteur (optionnel)

### Phase 3 (Learning Platform)
- Interface visuelle du cluster (sidebar/split view)
- Modes d'apprentissage guid√©s (lessons interactives)
- Syst√®me de challenges avec validation automatique
- Visualisation graphique de l'√©tat du cluster

---

## üéØ Crit√®res de succ√®s MVP

- Terminal fonctionnel et esth√©tique (centr√©, th√®me dark)
- Au moins 8 commandes kubectl support√©es (get, describe, delete, apply, create)
- Commandes shell basiques (cd, ls, pwd, mkdir, touch, cat, rm)
- Virtual filesystem fonctionnel (max 3 niveaux, persistance)
- Cluster stateful qui persiste entre sessions (localStorage)
- Filesystem persiste entre sessions (localStorage)
- Int√©gration kubectl + filesystem (`kubectl apply -f path/to/file.yaml`)
- Couverture de tests > 80%
- Code TypeScript strict mode
- Architecture modulaire et d√©coupl√©e (ClusterState + FileSystem)
- Messages d'erreur clairs et p√©dagogiques
- D√©pendances minimales (uniquement js-yaml en plus de xterm) [[memory:7046756]]

---

## üéì Learning Platform (Phase 3)

### Challenges System

**Objectif** : Sc√©narios pratiques o√π l'utilisateur doit r√©soudre un probl√®me r√©el

#### Mod√®le de donn√©es Challenge

```typescript
interface Challenge {
  id: string
  title: string
  description: string
  difficulty: "beginner" | "intermediate" | "advanced"
  category: "debugging" | "scaling" | "networking" | "security"
  
  // Seed cluster pr√©-configur√© pour ce challenge
  initialClusterState: ClusterState
  
  // Objectifs √† atteindre
  objectives: Objective[]
  
  // Hints progressifs
  hints: string[]
  
  // Validation
  validator: (state: ClusterState, history: string[]) => ValidationResult
}

interface Objective {
  id: string
  description: string
  isCompleted: (state: ClusterState) => boolean
}

type ValidationResult = 
  | { type: 'incomplete', nextHint?: string }
  | { type: 'success', message: string, score: number }
  | { type: 'failed', reason: string }
```

#### Exemples de Challenges

1. **"Debug a Crashing Pod"**
   - √âtat initial : Pod en CrashLoopBackOff
   - Objectif : Identifier le probl√®me et le corriger
   - Validation : Pod passe en Running

2. **"Scale a Deployment"**
   - √âtat initial : Deployment avec 1 replica sous charge
   - Objectif : Scaler √† 3 replicas
   - Validation : 3 pods Running avec bon label

3. **"Fix Networking Issue"**
   - √âtat initial : Service pointe vers mauvais pods
   - Objectif : Corriger les labels/selectors
   - Validation : Service expose les bons pods

4. **"Resource Cleanup"**
   - √âtat initial : Cluster avec ressources orphelines
   - Objectif : Supprimer pods non utilis√©s
   - Validation : Seulement pods essentiels restent

### Lessons System

**Objectif** : Tutoriels interactifs guid√©s avec th√©orie + pratique

#### Mod√®le de donn√©es Lesson

```typescript
interface Lesson {
  id: string
  title: string
  category: "basics" | "intermediate" | "advanced"
  duration: number  // minutes estim√©es
  
  // Contenu p√©dagogique
  sections: LessonSection[]
  
  // Cluster pour exp√©rimentation
  playgroundState?: ClusterState
  
  // Progression
  progress: number  // 0-100%
}

interface LessonSection {
  type: "text" | "example" | "exercise" | "quiz"
  title: string
  content: string | ExerciseContent | QuizContent
}

interface ExerciseContent {
  instruction: string
  expectedCommands?: string[]
  validator: (state: ClusterState, commands: string[]) => boolean
  solution: string
}
```

#### Exemples de Lessons

1. **"Introduction to Pods"**
   - Qu'est-ce qu'un Pod ?
   - Anatomy d'un Pod (containers, labels, status)
   - Exercice : Lister et inspecter des pods
   - Quiz : Identifier l'√©tat d'un Pod

2. **"Working with Deployments"**
   - Pourquoi les Deployments ?
   - Relation Deployment ‚Üí ReplicaSet ‚Üí Pods
   - Exercice : Cr√©er et scaler un deployment
   - Challenge : Rolling update

3. **"Kubernetes Networking Basics"**
   - Services et leurs types
   - Labels et selectors
   - Exercice : Exposer une app avec un Service

### Cluster Visualizer

**Objectif** : Vue graphique de l'√©tat du cluster pour mieux comprendre

#### Options de visualisation (√† explorer)

**Option 1: Tree View** (Plus simple)
```
üì¶ Namespaces
‚îú‚îÄ‚îÄ default
‚îÇ   ‚îú‚îÄ‚îÄ üöÄ Deployment: nginx-deployment (3/3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ Pod: nginx-abc123 (Running)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ Pod: nginx-def456 (Running)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ‚úÖ Pod: nginx-ghi789 (Running)
‚îÇ   ‚îî‚îÄ‚îÄ üîå Service: nginx-service (ClusterIP)
‚îî‚îÄ‚îÄ kube-system
    ‚îî‚îÄ‚îÄ ‚úÖ Pod: coredns-xyz (Running)
```

**Option 2: Graph View** (Plus avanc√©)
- Nodes visuels pour chaque ressource
- Fl√®ches pour les relations (Service ‚Üí Pods, Deployment ‚Üí Pods)
- Couleurs pour les √©tats (vert=healthy, rouge=error, jaune=warning)
- Canvas HTML5 ou SVG

**Option 3: Cards Grid** (Compromis)
- Cards daisyUI pour chaque ressource
- Disposition en grid responsive
- Ic√¥nes pour types de ressources
- Badges pour statuts

#### Impl√©mentation recommand√©e (Phase 3)

```typescript
// Factory function pour le visualizer
const createClusterVisualizer = (container: HTMLElement, mode: 'tree' | 'graph' | 'cards') => {
  let currentState: ClusterState
  
  const render = (state: ClusterState) => {
    currentState = state
    if (mode === 'tree') renderTree(container, state)
    if (mode === 'graph') renderGraph(container, state)
    if (mode === 'cards') renderCards(container, state)
  }
  
  const renderTree = (container: HTMLElement, state: ClusterState) => {
    // Pure HTML/CSS tree avec accord√©ons daisyUI
  }
  
  return {
    render,
    setMode: (newMode) => { mode = newMode; render(currentState) },
    destroy: () => { container.innerHTML = '' }
  }
}
```

### Int√©gration UI

#### Mode "Learning" Layout
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Header: [Mode selector] [Progress] [Help]              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                          ‚îÇ  Lesson Panel                ‚îÇ
‚îÇ  Terminal                ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  (70%)                   ‚îÇ  ‚îÇ Section 1: Pods        ‚îÇ  ‚îÇ
‚îÇ                          ‚îÇ  ‚îÇ Text + images          ‚îÇ  ‚îÇ
‚îÇ  kubectl>                ‚îÇ  ‚îÇ                        ‚îÇ  ‚îÇ
‚îÇ                          ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ  [< Previous] [Next >]       ‚îÇ
‚îÇ                          ‚îÇ                              ‚îÇ
‚îÇ                          ‚îÇ  Objectives: ‚úÖ ‚úÖ ‚¨ú        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Mode "Challenge" Layout
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Challenge: Debug Crashing Pod [üî• Hard]                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Terminal                ‚îÇ  Objectives                  ‚îÇ
‚îÇ                          ‚îÇ  ‚¨ú Find crashing pod        ‚îÇ
‚îÇ  kubectl>                ‚îÇ  ‚¨ú Identify error           ‚îÇ
‚îÇ                          ‚îÇ  ‚¨ú Fix and verify           ‚îÇ
‚îÇ                          ‚îÇ                              ‚îÇ
‚îÇ                          ‚îÇ  Hints (2/5 used)            ‚îÇ
‚îÇ                          ‚îÇ  üí° Try describe command     ‚îÇ
‚îÇ                          ‚îÇ  [Show next hint]            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Mode "Visual" Layout
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ [Terminal] [Visual] [Both]                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Terminal (50%)          ‚îÇ  Cluster Visualizer (50%)    ‚îÇ
‚îÇ                          ‚îÇ                              ‚îÇ
‚îÇ  kubectl> get pods       ‚îÇ  üì¶ default                  ‚îÇ
‚îÇ                          ‚îÇ  ‚îú‚îÄ üöÄ nginx-deploy         ‚îÇ
‚îÇ  NAME      STATUS        ‚îÇ  ‚îÇ  ‚îî‚îÄ ‚úÖ Pod (Running)     ‚îÇ
‚îÇ  nginx-1   Running       ‚îÇ  ‚îî‚îÄ üîå Service              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù Notes

- Privil√©gier les APIs web natives quand possible [[memory:7046756]]
- Garder le code simple et lisible
- Chaque module doit √™tre testable ind√©pendamment
- La simulation n'a pas besoin d'√™tre parfaite, juste p√©dagogiquement utile
- Phase 3 (Learning Platform) : √† concevoir apr√®s validation du MVP

